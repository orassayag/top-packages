'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _xregexp = require('xregexp');

var _xregexp2 = _interopRequireDefault(_xregexp);

const regex = Symbol();
const handlers = Symbol();

function getHandlerAttachError(message) {
  if (typeof message === 'string') {
    message += '; cannot attach handler';
  } else {
    message = 'Cannot attach handler';
  }
  return new Error(message);
}

function getHandlerDetachError(message) {
  if (typeof message === 'string') {
    message += '; cannot detach handler';
  } else {
    message = 'Cannot detach handler';
  }
  return new Error(message);
}

function validateHandlerId(handlers, id) {
  if (!Number.isSafeInteger(id) || id < 1) {
    return 'Invalid identifier \'' + id + '\'';
  }

  if (id > handlers.length) {
    return 'Identifier \'' + id + '\' is out of bounds';
  }

  return null;
}

function getNextId(ids) {
  for (let i = 1; i <= Number.MAX_SAFE_INTEGER; i++) {
    if (!ids[i]) {
      ids[i] = true;
      return i;
    }
  }
  return 0;
}

let Route = (function () {
  function Route() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    let route = _ref.route;
    var _ref$regex = _ref.regex;
    let isRegex = _ref$regex === undefined ? false : _ref$regex;
    let predefinedHandlers = _ref.handlers;

    _classCallCheck(this, Route);

    if (!(route instanceof RegExp || typeof route === 'string')) {
      throw new Error('Route must either be a regular expression or a string');
    }

    if (!isRegex && typeof route === 'string') {
      let routeParts = route.split('/');
      route = '^' + routeParts.map(part => {
        let escapedPart = part.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        return escapedPart.startsWith(':') ? '(?<' + escapedPart.slice(1) + '>[^/]+)' : escapedPart;
      }).join('/') + '$';
    }

    this[regex] = (0, _xregexp2['default'])(route);
    this[handlers] = [];
    this[handlers].ids = {};

    if (Array.isArray(predefinedHandlers)) {
      predefinedHandlers.forEach(handler => this.attachHandler(handler));
    }
  }

  _createClass(Route, [{
    key: 'matches',
    value: function matches(path) {
      return this[regex].test(path);
    }
  }, {
    key: 'parsePath',
    value: function parsePath(path) {
      let paramMatches = _xregexp2['default'].exec(path, this[regex]);
      let paramValues = {};
      this.params.forEach(param => paramValues[param] = paramMatches[param]);
      return paramValues;
    }
  }, {
    key: 'attachHandler',
    value: function attachHandler() {
      var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _ref2$methods = _ref2.methods;
      let methods = _ref2$methods === undefined ? 'ALL' : _ref2$methods;
      let handler = _ref2.handler;

      var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      let before = _ref3.before;
      let after = _ref3.after;
      let replace = _ref3.replace;

      if (!handler) {
        throw getHandlerAttachError('No handler given; cannot attach to route');
      }

      if (typeof methods === 'string') {
        methods = [methods];
      }

      if (!Array.isArray(methods)) {
        throw getHandlerAttachError('methods must either be a string or an array');
      }

      methods = methods.map(method => {
        if (typeof method !== 'string') {
          throw getHandlerAttachError('methods array must only contain strings');
        }

        let upperCaseMethod = method.toUpperCase();

        if (!['ALL', 'GET', 'POST', 'HEAD', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'CONNECT', 'PATCH'].find(validMethod => upperCaseMethod === validMethod)) {
          throw getHandlerAttachError('Invalid method \'' + method);
        }

        return upperCaseMethod;
      });

      let handlerObject = { methods: methods, handler: handler, id: getNextId(this[handlers].ids) };

      if (!handlerObject.id) {
        throw getHandlerAttachError('Exhausted maximum number of handlers');
      }

      let placementOptionCount = (before ? 1 : 0) + (after ? 1 : 0) + (replace ? 1 : 0);

      if (placementOptionCount > 1) {
        throw new Error('before, after, and replace cannot be used together');
      } else if (placementOptionCount) {
        let id = before || after || replace;
        let idValidationError = validateHandlerId(this[handlers], id);

        if (idValidationError) {
          throw getHandlerAttachError(idValidationError);
        }

        let index = this[handlers].findIndex(handler => handler.id === id);

        if (index === -1) {
          throw getHandlerAttachError('No handler with id ' + id);
        }

        if (before) {
          this[handlers].splice(index, 0, handlerObject);
        } else if (after) {
          this[handlers].splice(index + 1, 0, handlerObject);
        } else if (replace) {
          delete this[handlers].ids[this[handlers][index].id];
          this[handlers].splice(index, 1, handlerObject);
        }
      } else {
        this[handlers].push(handlerObject);
      }

      return handlerObject.id;
    }
  }, {
    key: 'detachHandler',
    value: function detachHandler(id) {
      let idValidationError = validateHandlerId(this[handlers], id);

      if (idValidationError) {
        throw getHandlerDetachError(idValidationError);
      }

      let index = this[handlers].findIndex(handler => handler.id === id);

      if (index === -1) {
        throw getHandlerDetachError('No handler with id ' + id);
      }

      delete this[handlers].ids[this[handlers][index].id];
      this[handlers].splice(index, 1);
    }
  }, {
    key: 'getHandlers',
    value: function getHandlers(method) {
      if (typeof method !== 'string') {
        throw new Error('method must be a string');
      }

      method = method.toUpperCase();

      return this[handlers].filter(handler => handler.methods.find(handlerMethod => handlerMethod === 'ALL' || handlerMethod === method)).map(handler => handler.handler);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this[regex].xregexp.source;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this[regex].xregexp.source;
    }
  }, {
    key: 'params',
    get: function get() {
      return this[regex].xregexp.captureNames ? this[regex].xregexp.captureNames.filter(name => name !== null) : [];
    }
  }]);

  return Route;
})();

exports['default'] = Route;
module.exports = exports['default'];